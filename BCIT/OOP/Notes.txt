Héritage/Polymorphisme :
- on peut faire Type1 obj = new Type2() même si la classe Type1 est abstraite, ssi la classe Type2 n'est pas abstraite
class A {
    private int x;

    class B {
        private int x;

        class C {
            int getX() {
                return x; // Cet x fait référence au champ x de la classe B
            }
        }
    }
} --> renverra le x de la classe B

Interfaces :
- Les variables d'une interface doivent être définies et une fois définies elles sont statiques et finales
- Une fois définies, les méthodes doivent être explicitement publiques

Type Generic :
- dans le prototype de la fonction doit apparaître, entre < >, tous les types génériques qui sont demandés en argument (séparés par des virgules si plusieurs)
	--> il n'est pas nécessaire si le type est déjà défini au niveau de la classe (ex : public class A <T extends Number>)
- si on utilise des types qui ont des héritage, il faut faire <T extends A> ce qui va associer à T toutes les classes héritées de A (direct ou indirect) et A elle même
	--> <? extends A> permet d'utiliser toutes les sous-classes de A mais pas A lui même ???
- Une classe normale peut implémenter une interface générique et une classe générique peut implémenter une interface classique
- une classe/interface générique peut avoir plusieurs méthodes qui portent le même nom ssi leur signature sont toutes différentes
- une classe normale peut contenir des méthodes génériques et inversement
- <? extends T> : Vous pouvez obtenir des éléments du conteneur mais vous ne pouvez pas y ajouter de nouveaux éléments.
- <? super T> : Vous pouvez ajouter des éléments au conteneur mais vous ne pouvez pas garantir le type spécifique que vous pouvez obtenir de ce conteneur.


Collections :
    - Si on copie une array qui contient des objets, on fera simplement une copie des références des objets, donc pas de nouveaux objets créés
    - On ne peut pas utiliser de boucle for each si on compte modifier la liste. On peut par contre utiliser :
        - une boucle for ou while avec un index int
        - utiliser un objet Iterator (on ne peut pas les utiliser sur des tableaux)
    - Un objet iterator est un objet qui permet d'itérer de manière sécurisée :
        (List)Iterator<TYPE> iterator = listeName.(list)Iterator(); (dans Iterator(), on peut mettre listeName.size() mais pas de valeur explicite (même pas 0))
        forme de la boucle while (fonctionne aussi avec une boucle for)
        while(iterator.hasNext() / iterator.hasPrevious){
            TYPE elt = iterator.next()/iterator.previous();
            // fonction de la boucle
        }    
    
Threads :
	- la classe qui les utilise doit avoir extends Thread implements Runnable
	- pour créer un Thread :
		* si on étend Thread : Thread t = new Thread() puis t.start()
		* si on implémente Runnable: on crée un objet Runnable qu'on passe en argument quand on crée un objet Thread
	- pour lancer un thread : <thread name>.start() : lance et exécute la méthode run() de <thread name>
		--> pour éviter qu'il se chevauche avec d'autres Threads, on peut utiliser la méthode <thread name>.join() jsute après le lancement du thread
	- la classe Runnable ne permet pas de renvoyer des valeurs tandis que la classe Callable oui :
		--> pour les lancer, on utiliser la méthode .call() à la place de start() mais fait la même chose
		--> on peut le récupérer grâce à <callable objet>.get()
	- la méthode <thread name>.sleep permet de mettre en pause un certain Thread. Lorsqu'il attend, le thread suivant se met en route
		--> .join() comprend qu'il ne faut pas considérer un thread en pause comme un thread fini (doit être utilisé dans le bloc try d'un try-catch (erreur de compilation sinon)
		--> .yield() (À REVOIR) (si j'ai bien compris, il appelle tous les threads, même ceux pas en attente, alors que notifyAll appelle uniquement tous les threads en attente)

Race conditions, locks et deadlocks :
	- race condition : contexte dans lequel plusieurs threads tentent d'accéder/modifier à une données partagées
	- pour éviter d'avoir des problèmes de ce genre, on peut utiliser des locks :
		--> si l'exécution du thread renvoie une erreur, l'état du thread est indéfini
		--> synchronized au début de la déclaration de la fonction : synchronized void foo(){}
		--> synchronized (objectName) à l'intérieur de la fonction : void foo(){ synchronized(objectName){...} }
	- pour bloquer un block de code sur un objet, il faut faire : synchronized(myObject){ // code }
	- Lorsque vous synchronisez un bloc ou une méthode avec le mot-clé synchronized seul, cela bloque le bloc ou la méthode pour l'exécution d'un seul thread à la fois. Cela signifie que si un thread exécute ce bloc ou cette méthode, aucun autre thread ne peut y accéder tant que le premier thread n'a pas terminé son exécution.
	-Lorsque vous utilisez synchronized(myObject) pour synchroniser sur un objet spécifique, cela signifie que le bloc ou la méthode est bloqué pour tous les threads qui tentent d'accéder au même objet (c'est-à-dire l'objet myObject). Cela signifie que plusieurs threads peuvent exécuter simultanément différentes méthodes synchronisées si ces méthodes sont synchronisées sur des objets différents. Cependant, si plusieurs threads tentent d'accéder au même bloc ou à la même méthode synchronisée sur le même objet, un seul thread pourra y accéder à la fois.
	- Lorsque vous utilisez static synchronized(myClass) pour synchroniser une méthode statique sur une classe, cela bloque l'accès à la méthode pour tous les threads jusqu'à ce que le thread actuel ait terminé son exécution de la méthode. Cela signifie que si une méthode est déclarée comme static synchronized, elle est bloquée pour tous les threads, qu'ils travaillent avec la même instance de classe ou non. La synchronisation s'applique au niveau de la classe plutôt qu'au niveau de l'objet.

Inner classes and interfaces :
	- un objet d'une classe statique n'a pas besoin de ses outer classes pour être créé
	- depuis une classe statique, on ne peut pas accéder à un élément non statique d'une autre classe sans appeler un objet de cette classe
	- pour créer un objet objet d'une classe2 à l'intérieur d'une classe1 :
		* mettre en statique la classe2
		* classe1.classe objet = new class1.classe2();
	- pour appeler un méthode de class2 : objet.method();
	- Si on a la configuration suivante :
		class A{
			T foo(){}
		}
		class B extends A{
			U foo(){}
		}
		--> U doit être égal ou étendre à T
	
Expressions lambdas :
	- à partir du moment où on a une interface :
		--> <interface> <nomObjet> = ([liste des paramètres]) -> <ce que ça fait et retourne>
